## 1.Hãy Viết code triển khai 7 flow cụ thể cho tôi . để tôi sử dụng được qua postman API.
2.Hãy triển khai Code theo kiến trúc database đã phân tích @v2.Database Schema Design.md 

Tôi sẽ giúp bạn triển khai code cho 7 flow chính của hệ thống, sử dụng Spring Boot và các công nghệ đã định nghĩa trong kiến trúc.

Đầu tiên, hãy tạo cấu trúc project Spring Boot:

````java:src/main/java/com/llm/system/config/DatabaseConfig.java
@Configuration
@EnableTransactionManagement
public class DatabaseConfig {

    @Bean
    @Primary
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource dataSource() {
        return DataSourceBuilder.create()
            .type(HikariDataSource.class)
            .build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(
            EntityManagerFactoryBuilder builder, DataSource dataSource) {
        return builder
            .dataSource(dataSource)
            .packages("com.llm.system.entity")
            .persistenceUnit("llm")
            .properties(additionalProperties())
            .build();
    }

    private Map<String, Object> additionalProperties() {
        Map<String, Object> props = new HashMap<>();
        props.put("hibernate.dialect", "org.hibernate.dialect.PostgreSQLDialect");
        props.put("hibernate.show_sql", "true");
        props.put("hibernate.format_sql", "true");
        return props;
    }
}
````

Tiếp theo là các entity chính:

````java:src/main/java/com/llm/system/entity/Project.java
@Entity
@Table(name = "projects")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Project {
    @Id
    @GeneratedValue(generator = "UUID")
    @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator")
    @Column(name = "project_id", updatable = false, nullable = false)
    private UUID projectId;

    @Column(name = "user_id", nullable = false)
    private UUID userId;

    @Column(name = "project_name", nullable = false)
    private String projectName;

    @Column(name = "project_description")
    private String projectDescription;

    @Column(name = "api_key", nullable = false)
    private UUID apiKey;

    @Column(name = "status")
    @Builder.Default
    private String status = "active";

    @Column(name = "priority")
    @Builder.Default
    private Integer priority = 1;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @Column(name = "deadline")
    private LocalDateTime deadline;

    @Type(type = "jsonb")
    @Column(columnDefinition = "jsonb")
    private Map<String, Object> metadata;

    @Type(type = "jsonb")
    @Column(columnDefinition = "jsonb")
    private Map<String, Object> settings;
}
````

````java:src/main/java/com/llm/system/entity/Task.java
@Entity
@Table(name = "tasks")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Task {
    @Id
    @GeneratedValue(generator = "UUID")
    @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator")
    @Column(name = "task_id", updatable = false, nullable = false)
    private UUID taskId;

    @Column(name = "project_id", nullable = false)
    private UUID projectId;

    @Column(name = "user_id", nullable = false)
    private UUID userId;

    @Column(name = "task_type", nullable = false)
    private String taskType;

    @Column(name = "priority")
    @Builder.Default
    private Integer priority = 1;

    @Column(name = "status", nullable = false)
    @Builder.Default
    private String status = "pending";

    @Type(type = "jsonb")
    @Column(columnDefinition = "jsonb", nullable = false)
    private Map<String, Object> inputData;

    @Type(type = "jsonb")
    @Column(columnDefinition = "jsonb")
    private Map<String, Object> outputData;

    @Column(name = "error_message")
    private String errorMessage;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @Column(name = "started_at")
    private LocalDateTime startedAt;

    @Column(name = "completed_at")
    private LocalDateTime completedAt;

    @Column(name = "deadline")
    private LocalDateTime deadline;

    @Column(name = "assigned_worker_id")
    private UUID assignedWorkerId;

    @Column(name = "retry_count")
    @Builder.Default
    private Integer retryCount = 0;

    @Column(name = "max_retries")
    @Builder.Default
    private Integer maxRetries = 3;

    @Column(name = "parent_task_id")
    private UUID parentTaskId;

    @Column(name = "execution_order")
    private Integer executionOrder;

    @Type(type = "jsonb")
    @Column(columnDefinition = "jsonb")
    private Map<String, Object> metadata;
}
````

Bây giờ là các service chính cho 7 flow:

````java:src/main/java/com/llm/system/service/ProjectService.java
@Service
@Slf4j
@RequiredArgsConstructor
public class ProjectService {
    private final ProjectRepository projectRepository;
    private final TaskService taskService;
    private final KafkaTemplate<String, Task> kafkaTemplate;

    @Transactional
    public Project createProject(ProjectRequest request) {
        log.info("Creating new project: {}", request.getProjectName());
        
        Project project = Project.builder()
            .userId(request.getUserId())
            .projectName(request.getProjectName())
            .projectDescription(request.getDescription())
            .apiKey(UUID.randomUUID())
            .status("active")
            .priority(request.getPriority())
            .deadline(request.getDeadline())
            .metadata(request.getMetadata())
            .settings(request.getSettings())
            .build();

        return projectRepository.save(project);
    }

    @Transactional
    public Task createProjectTask(UUID projectId, TaskRequest request) {
        Project project = projectRepository.findById(projectId)
            .orElseThrow(() -> new ProjectNotFoundException(projectId));

        Task task = Task.builder()
            .projectId(projectId)
            .userId(project.getUserId())
            .taskType(request.getTaskType())
            .priority(request.getPriority())
            .inputData(request.getInputData())
            .deadline(request.getDeadline())
            .build();

        Task savedTask = taskService.saveTask(task);
        kafkaTemplate.send("task-topic", savedTask);
        
        return savedTask;
    }
}
````

````java:src/main/java/com/llm/system/service/TaskAnalyzerService.java
@Service
@Slf4j
@RequiredArgsConstructor
public class TaskAnalyzerService {
    private final TaskRepository taskRepository;
    private final KafkaTemplate<String, Task> kafkaTemplate;

    @KafkaListener(topics = "task-topic")
    public void analyzeTask(Task task) {
        log.info("Analyzing task: {}", task.getTaskId());

        try {
            // Phân tích task và chia nhỏ nếu cần
            List<Task> subTasks = analyzeAndSplitTask(task);
            
            // Cập nhật task gốc
            task.setStatus("analyzing");
            taskRepository.save(task);

            // Gửi các sub-task vào queue xử lý
            for (Task subTask : subTasks) {
                kafkaTemplate.send("subtask-topic", subTask);
            }

        } catch (Exception e) {
            log.error("Error analyzing task: {}", task.getTaskId(), e);
            task.setStatus("analysis_failed");
            task.setErrorMessage(e.getMessage());
            taskRepository.save(task);
        }
    }

    private List<Task> analyzeAndSplitTask(Task parentTask) {
        // Logic phân tích và chia nhỏ task
        List<Task> subTasks = new ArrayList<>();
        
        // Ví dụ chia task thành 3 phần cho 3 LLM khác nhau
        String[] llmTypes = {"openai", "claude", "gemini"};
        
        for (int i = 0; i < llmTypes.length; i++) {
            Task subTask = Task.builder()
                .projectId(parentTask.getProjectId())
                .userId(parentTask.getUserId())
                .taskType(llmTypes[i])
                .parentTaskId(parentTask.getTaskId())
                .executionOrder(i + 1)
                .priority(parentTask.getPriority())
                .inputData(parentTask.getInputData())
                .status("pending")
                .build();
                
            subTasks.add(taskRepository.save(subTask));
        }
        
        return subTasks;
    }
}
````

````java:src/main/java/com/llm/system/service/LLMProcessingService.java
@Service
@Slf4j
@RequiredArgsConstructor
public class LLMProcessingService {
    private final TaskRepository taskRepository;
    private final ResultRepository resultRepository;
    private final Map<String, LLMProcessor> llmProcessors;

    @KafkaListener(topics = "subtask-topic")
    public void processTask(Task task) {
        log.info("Processing task with LLM: {}", task.getTaskType());

        try {
            task.setStatus("processing");
            task.setStartedAt(LocalDateTime.now());
            taskRepository.save(task);

            // Lấy processor tương ứng với loại LLM
            LLMProcessor processor = llmProcessors.get(task.getTaskType());
            
            // Xử lý task
            Map<String, Object> output = processor.process(task.getInputData());
            
            // Lưu kết quả
            Result result = Result.builder()
                .taskId(task.getTaskId())
                .engineType(task.getTaskType())
                .outputData(output)
                .status("completed")
                .build();
            
            resultRepository.save(result);

            // Cập nhật trạng thái task
            task.setStatus("completed");
            task.setCompletedAt(LocalDateTime.now());
            task.setOutputData(output);
            taskRepository.save(task);

        } catch (Exception e) {
            log.error("Error processing task: {}", task.getTaskId(), e);
            task.setStatus("failed");
            task.setErrorMessage(e.getMessage());
            taskRepository.save(task);
        }
    }
}
````

Cuối cùng là controller để expose API:

````java:src/main/java/com/llm/system/controller/ProjectController.java
@RestController
@RequestMapping("/api/v1/projects")
@RequiredArgsConstructor
public class ProjectController {
    private final ProjectService projectService;

    @PostMapping
    public ResponseEntity<Project> createProject(@RequestBody ProjectRequest request) {
        Project project = projectService.createProject(request);
        return ResponseEntity.ok(project);
    }

    @PostMapping("/{projectId}/tasks")
    public ResponseEntity<Task> createProjectTask(
            @PathVariable UUID projectId,
            @RequestBody TaskRequest request) {
        Task task = projectService.createProjectTask(projectId, request);
        return ResponseEntity.ok(task);
    }

    @GetMapping("/{projectId}/tasks")
    public ResponseEntity<List<Task>> getProjectTasks(@PathVariable UUID projectId) {
        List<Task> tasks = projectService.getProjectTasks(projectId);
        return ResponseEntity.ok(tasks);
    }

    @GetMapping("/{projectId}/tasks/{taskId}")
    public ResponseEntity<TaskDetails> getTaskDetails(
            @PathVariable UUID projectId,
            @PathVariable UUID taskId) {
        TaskDetails details = projectService.getTaskDetails(projectId, taskId);
        return ResponseEntity.ok(details);
    }
}
````

Để sử dụng qua Postman, bạn có thể gọi các API sau:

1. Tạo Project mới:
```
POST /api/v1/projects
{
    "userId": "uuid-here",
    "projectName": "Test Project",
    "description": "Project description",
    "priority": 1,
    "deadline": "2024-12-31T23:59:59",
    "metadata": {},
    "settings": {}
}
```

2. Tạo Task trong Project:
```
POST /api/v1/projects/{projectId}/tasks
{
    "taskType": "text_analysis",
    "priority": 1,
    "inputData": {
        "text": "Your text to analyze",
        "options": {
            "language": "vi",
            "maxTokens": 1000
        }
    },
    "deadline": "2024-12-31T23:59:59"
}
```

3. Xem danh sách Task của Project:
```
GET /api/v1/projects/{projectId}/tasks
```

4. Xem chi tiết Task:
```
GET /api/v1/projects/{projectId}/tasks/{taskId}
```

Bạn cần thêm các file cấu hình sau:

````properties:src/main/resources/application.yml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/llm_system
    username: your_username
    password: your_password
    driver-class-name: org.postgresql.Driver
    
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      group-id: llm-processing-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
````

Bạn có cần tôi giải thích thêm về phần nào không?
